package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-swagger/go-swagger/errors"
	"github.com/go-swagger/go-swagger/httpkit/validate"
	"github.com/go-swagger/go-swagger/strfmt"
)

/*A rate plan describes a pricing system under which a subscription can be made to a product.

swagger:model ProductRatePlan
*/
type ProductRatePlan struct {

	/* {"default":"(empty list)","description":"List of AggregatingComponents &mdash; these describe pricing components whose prices should be recalculated upon invoice aggregation. For example: two subscriptions' individual consumptions may be neither of them large enough to achieve bulk-buy discounts. When aggregated, though, the same two subscriptions' consumption may add up to a quantity which does merit a bulk buy discount within your tiering system.","verbs":["POST"]}
	 */
	AggregatingComponents []*AggregatingComponent `json:"aggregatingComponents,omitempty"`

	/* BillingEntity billing entity
	 */
	BillingEntity string `json:"billingEntity,omitempty"`

	/* { "description" : "ID of the user who last updated the entity.", "verbs":[] }
	 */
	ChangedBy string `json:"changedBy,omitempty"`

	/* {"default":"true","description":"Whether invoices are created if they have a zero valued cost before any discounts are applied.","verbs":["POST","PUT","GET"] }

	Required: true
	*/
	CreateZeroValuedInvoices bool `json:"createZeroValuedInvoices,omitempty"`

	/* { "description" : "The UTC DateTime when the object was created.", "verbs":[] }
	 */
	Created strfmt.DateTime `json:"created,omitempty"`

	/* Crmid crmid
	 */
	Crmid string `json:"crmid,omitempty"`

	/* {"description":"The currency of the product-rate-plan &mdash; as specified by a three-character ISO 4217 currency code (i.e. USD).","verbs":["POST","GET"]}

	Required: true
	*/
	Currency string `json:"currency,omitempty"`

	/* DisplayName display name
	 */
	DisplayName string `json:"displayName,omitempty"`

	/* {"description":"Number of length-measures which constitute the rate plan's period. If left unspecified: the rate plan will use the same `duration` number as the Product to which it belongs.","verbs":["POST","GET"]}
	 */
	Duration int32 `json:"duration,omitempty"`

	/* {"description":"Measure describing the magnitude of the rate plan's period. If left unspecified: the rate plan will use the same `durationPeriod` magnitude as the Product to which it belongs.","verbs":["POST","GET"]}

	Required: true
	*/
	DurationPeriod string `json:"durationPeriod,omitempty"`

	/* {"default":"None","description":"The action that should be taken, should an invoice for some subscription to this rate plan remain unpaid despite the dunning period's being exceeded.<br><span class=\"label label-default\">CancelSubscription</span> &mdash; Demotes the subscription to the `Failed` state as soon as the dunning period is exceeded.<br><span class=\"label label-default\">None</span> &mdash; The subscription is allowed to continue in the `AwaitingPayment` state indefinitely even if the dunning period is exceeded.For slow payment cycles &mdash; or when manual invoice remediation is common &mdash; <span class=\"label label-default\">None</span> is recommended.<br>In a heavily-automated SaaS environment, automatic cancellation via <span class=\"label label-default\">CancelSubscription</span> is recommended.","verbs":["POST","PUT","GET"]}

	Required: true
	*/
	FailedPaymentBehaviour string `json:"failedPaymentBehaviour,omitempty"`

	/* {"description":"A list linking \"Fixed-Term Definitions\" to the rate plan.","verbs":["POST","PUT","GET"]}
	 */
	FixedTermDefinitions []*MutableBillingEntity `json:"fixedTermDefinitions,omitempty"`

	/* { "description" : "", "verbs":["GET", "PUT"] }
	 */
	ID string `json:"id,omitempty"`

	/* {"default":"<span class=\"label label-default\">Immediate</span>","description":"The strategy for how invoices for this plan will be issued.<br><span class=\"label label-default\">Immediate</span> &mdash; All generated invoices move immediately to the 'Unpaid' state &mdash; beginning the payment pursuit process.<br><span class=\"label label-default\">Delayed</span> &mdash; All generated invoices begin in the 'Pending' state. An 'Issue Invoice' amendment is scheduled (based on the rate plan's `issueDuration` and `issuePeriod`) that will move the invoice to the 'Unpaid' state (beginning the payment pursuit process) in accordance with the rate plan's issuance schedule.<br><span class=\"label label-default\">Manual</span> &mdash; All generated invoices sit in the 'Pending' state &mdash; they will not be issued to the customer unless explicit action is taken. This gives you an opportunity to review or recalculate the invoice."verbs":["POST","GET"]}
	 */
	InvoiceIssueType string `json:"invoiceIssueType,omitempty"`

	/* {"description":"Number of issue-length-measures between issuance of invoices for this rate plan.""verbs":["POST","GET"]}
	 */
	IssueDuration int32 `json:"issueDuration,omitempty"`

	/* {"description":"Measure describing the magnitude of the invoice issuance period.","verbs":["POST","GET"]}
	 */
	IssuePeriod string `json:"issuePeriod,omitempty"`

	/* {"default":"false","description":"Whether the taxes of the rate plan take into account localised taxes.","verbs":["POST","PUT","GET"] }

	Required: true
	*/
	LocalisedTax bool `json:"localisedTax,omitempty"`

	/* {"default":"CreditAccount","description":"The action that should be taken, should the pro-rata calculation result in a negative value.<br><span class=\"label label-default\">NoCharge</span> &mdash; Don't return to the customer any money.<br><span class=\"label label-default\">CreditAccount</span> &mdash; Credit the customer's account with the amount.","verbs":["POST","PUT","GET"]}

	Required: true
	*/
	MigrationBehaviour string `json:"migrationBehaviour,omitempty"`

	/* {"description":"A friendly name &mdash; for your benefit &mdash; used to identify this rate plan within some product in BillForward. The name should reflect the fact that this rate plan provides to the customer a price tiering system within which a subscription to its Product can be made. <br>The rate plan's name could describe the nature of its price tiering (e.g. \"Default pricing\", \"Student pricing\").<br>Remember also that rate plans can override the timing prescribed by their product. If your rate plan is defined by its overriding the default timing of its product, then that can be reflected in that rate plan's name. (e.g. \"Student pricing - Annual\").","verbs":["POST","PUT","GET"]}

	Required: true
	*/
	Name string `json:"name,omitempty"`

	/* NotificationObjectGraph notification object graph
	 */
	NotificationObjectGraph string `json:"notificationObjectGraph,omitempty"`

	/* {"description":"The pricing-components which describe the price tiering system of this rate plan. A product rate plan may have 1 or more pricing components. Each pricing component represents a different charge associated with the subscription. Pricing components are versioned.","verbs":["POST","PUT","GET"]}

	Required: true
	*/
	PricingComponents []*PricingComponent `json:"pricingComponents,omitempty"`

	/* {"default":"WithCoupon","description":"The pro-rata mode for the rate plan. <br><span class=\"label label-default\">None</span> &mdash; The pro-rata cost for upgrades will be ignored.<br><span class=\"label label-default\">WithCoupon</span> &mdash; The pro-rata cost for upgrades will be calculated based on the time remaining for the subscription. Discounts from any attached coupons will be deducted from the pro-rated cost.<br><span class=\"label label-default\">WithoutCoupon</span> &mdash; The pro-rata cost for upgrades will be calculated based on the time remaining for the subscription. Discounts from any attached coupons will not be deducted from the pro-rated cost. ","verbs":[]}

	Required: true
	*/
	ProRataMode string `json:"proRataMode,omitempty"`

	/* {"description":"The product to which this rate plan belongs. A product is essentially a collection of rate plans, and describes the service conferred to a customer upon subscription to any of said product's rate plans. The product serves also as a template from which its rate plans can infer default attributes.","verbs":["POST","GET"]}
	 */
	Product *Product `json:"product,omitempty"`

	/* {"description":"ID of the product to which this rate plan belongs. A product is essentially a collection of rate plans, and describes the service conferred to a customer upon subscription to any of said product's rate plans. The product serves also as a template from which its rate plans can infer default attributes.","verbs":["POST","GET"]}

	Required: true
	*/
	ProductID string `json:"productID,omitempty"`

	/* {"default":"recurring","description":"The frequency of the rate plan &mdash; either recurring or non-recurring. If left unspecified: the rate plan will use the same `productType` frequency as the Product to which it belongs.","verbs":["POST","PUT","GET"]}
	 */
	ProductType string `json:"productType,omitempty"`

	/* {"description":"A friendly non-unique name used to identify this product","verbs":["POST","PUT","GET"]}
	 */
	PublicName string `json:"publicName,omitempty"`

	/* RecursionType recursion type
	 */
	RecursionType string `json:"recursionType,omitempty"`

	/* {"description":"The current status of the rate plan.","verbs":[]}
	 */
	Status string `json:"status,omitempty"`

	/* {"default":"inclusive","description":"The tax status of the product-rate-plan &mdash; either inclusive or exclusive.<br><span class=\"label label-default\">exclusive</span>pricing indicates that the cost of the Pricing Components do not include tax; when BillForward generates an Invoice, the tax will be calculated with this price as a base. <br>Tax-<span class=\"label label-default\">inclusive</span>pricing indicates that the Pricing components include Tax. BillForward will still calculate tax on each invoice. Tax will be calculated from the sales price.","verbs":["POST","PUT","GET"]}

	Required: true
	*/
	TaxStatus string `json:"taxStatus,omitempty"`

	/* {"description":"A list linking taxation strategies to the rate plan.","verbs":["POST","GET","PUT"]}
	 */
	Taxation []*MutableBillingEntity `json:"taxation,omitempty"`

	/* {"default":0,"description":"Number of trial-length-measures which constitute the rate plan's trial period. If left unspecified: the rate plan will use the same `trial` number as the Product to which it belongs.","verbs":["POST","PUT","GET"]}
	 */
	Trial int32 `json:"trial,omitempty"`

	/* {"default":"none","description":"Measure describing the magnitude of the rate plan's trial period. If left unspecified: the rate plan will use the same `trialPeriod` magnitude as the Product to which it belongs.","verbs":["POST","PUT","GET"]}
	 */
	TrialPeriod string `json:"trialPeriod,omitempty"`

	/* { "description" : "The UTC DateTime when the object was last updated. ", "verbs":[] }
	 */
	Updated strfmt.DateTime `json:"updated,omitempty"`

	/* {"description":"The UTC DateTime specifying when the rate plan is valid from.","verbs":["GET"]}
	 */
	ValidFrom strfmt.DateTime `json:"validFrom,omitempty"`

	/* {"description":"The UTC DateTime specifying when the product-rate-plan is valid till.","verbs":["GET"]}
	 */
	ValidTill strfmt.DateTime `json:"validTill,omitempty"`
}

// Validate validates this product rate plan
func (m *ProductRatePlan) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBillingEntity(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCreateZeroValuedInvoices(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDurationPeriod(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFailedPaymentBehaviour(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateInvoiceIssueType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateIssuePeriod(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLocalisedTax(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMigrationBehaviour(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePricingComponents(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProRataMode(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProductID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProductType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRecursionType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTaxStatus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTrialPeriod(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var productRatePlanBillingEntityEnum []interface{}

func (m *ProductRatePlan) validateBillingEntityEnum(path, location string, value string) error {
	if productRatePlanBillingEntityEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["Notification","Organization","OrganizationGateway","Product","User","Subscription","Profile","ProductRatePlan","Client","Invoice","PricingComponentValue","Account","PricingComponentValueChange","PricingComponentTier","PricingComponent","PricingCalculation","CouponDefinition","CouponInstance","CouponModifier","CouponRule","CouponBookDefinition","CouponBook","InvoiceLine","Webhook","SubscriptionCancellation","NotificationSnapshot","InvoicePayment","InvoiceLinePayment","Payment","PaymentMethod","PaymentMethodSubscriptionLink","DunningLine","CybersourceToken","Card","Alias","PaypalSimplePaymentReconciliation","FreePaymentReconciliation","LocustworldPaymentReconciliation","CouponInstanceExistingValue","TaxLine","TaxationStrategy","TaxationLink","Address","AmendmentPriceNTime","Authority","UnitOfMeasure","SearchResult","Amendment","AuditLog","Password","Username","FixedTermDefinition","FixedTerm","Refund","CreditNote","Receipt","AmendmentCompoundConstituent","APIConfiguration","StripeToken","BraintreeToken","BalancedToken","PaypalToken","AuthorizeNetToken","SpreedlyToken","GatewayRevenue","AmendmentDiscardAmendment","CancellationAmendment","CompoundAmendment","CompoundAmendmentConstituent","FixedTermExpiryAmendment","InvoiceNextExecutionAttemptAmendment","PricingComponentValueAmendment","BraintreeMerchantAccount","WebhookSubscription","Migration","CassResult","CassPaymentResult","CassProductRatePlanResult","CassChurnResult","CassUpgradeResult","SubscriptionCharge","CassPaymentPProductResult","ProductPaymentsArgs","StripeACHToken","UsageAmount","UsageSession","Usage","UsagePeriod","Period","OfflinePayment","CreditNotePayment","CardVaultPayment","FreePayment","BraintreePayment","BalancedPayment","CybersourcePayment","PaypalPayment","PaypalSimplePayment","LocustWorldPayment","StripeOnlyPayment","ProductPaymentsResult","StripeACHPayment","AuthorizeNetPayment","CompoundUsageSession","CompoundUsage","UsageRoundingStrategies","BillforwardManagedPaymentsResult","PricingComponentValueMigrationChargeAmendmentMapping","SubscriptionLTVResult","AccountLTVResult","ProductRatePlanPaymentsResult","DebtsResult","AccountPaymentsResult","ComponentChange","QuoteRequest","Quote","CouponCharge","CouponInstanceInvoiceLink","Coupon","CouponDiscount","CouponUniqueCodesRequest","CouponUniqueCodesResponse","GetCouponsResponse","AddCouponCodeRequest","AddCouponCodeResponse","RemoveCouponFromSubscriptionRequest","TokenizationPreAuth","StripeTokenizationPreAuth","BraintreeTokenizationPreAuth","SpreedlyTokenizationPreAuth","SagePayTokenizationPreAuth","PayVisionTokenizationPreAuth","TokenizationPreAuthRequest","AuthCaptureRequest","StripeACHBankAccountVerification","PasswordReset","PricingRequest","AddTaxationStrategyRequest","AddPaymentMethodRequest","APIRequest","SagePayToken","SagePayNotificationRequest","SagePayNotificationResponse","SagePayOutstandingTransaction","SagePayEnabledCardType","TrustCommerceToken","SagePayTransaction","PricingComponentValueResponse","MigrationResponse","TimeResponse","EntityTime","Email","AggregationLink","BFPermission","Role","PermissionLink","PayVisionToken","PayVisionTransaction","KashToken","EmailProvider","DataSynchronizationJob","DataSynchronizationJobError","DataSynchronizationConfiguration","DataSynchronizationAppConfiguration","AggregationChildrenResponse","MetadataKeyValue","Metadata","AggregatingComponent","PricingComponentMigrationValue","InvoiceRecalculationAmendment","IssueInvoiceAmendment","EmailSubscription","RevenueAttribution"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanBillingEntityEnum = append(productRatePlanBillingEntityEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanBillingEntityEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateBillingEntity(formats strfmt.Registry) error {

	if err := m.validateBillingEntityEnum("billingEntity", "body", m.BillingEntity); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validateCreateZeroValuedInvoices(formats strfmt.Registry) error {

	if err := validate.Required("createZeroValuedInvoices", "body", bool(m.CreateZeroValuedInvoices)); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("currency", "body", string(m.Currency)); err != nil {
		return err
	}

	return nil
}

var productRatePlanDurationPeriodEnum []interface{}

func (m *ProductRatePlan) validateDurationPeriodEnum(path, location string, value string) error {
	if productRatePlanDurationPeriodEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["minutes","days","months","years"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanDurationPeriodEnum = append(productRatePlanDurationPeriodEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanDurationPeriodEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateDurationPeriod(formats strfmt.Registry) error {

	if err := validate.Required("durationPeriod", "body", string(m.DurationPeriod)); err != nil {
		return err
	}

	if err := m.validateDurationPeriodEnum("durationPeriod", "body", m.DurationPeriod); err != nil {
		return err
	}

	return nil
}

var productRatePlanFailedPaymentBehaviourEnum []interface{}

func (m *ProductRatePlan) validateFailedPaymentBehaviourEnum(path, location string, value string) error {
	if productRatePlanFailedPaymentBehaviourEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["CancelSubscription","None"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanFailedPaymentBehaviourEnum = append(productRatePlanFailedPaymentBehaviourEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanFailedPaymentBehaviourEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateFailedPaymentBehaviour(formats strfmt.Registry) error {

	if err := validate.Required("failedPaymentBehaviour", "body", string(m.FailedPaymentBehaviour)); err != nil {
		return err
	}

	if err := m.validateFailedPaymentBehaviourEnum("failedPaymentBehaviour", "body", m.FailedPaymentBehaviour); err != nil {
		return err
	}

	return nil
}

var productRatePlanInvoiceIssueTypeEnum []interface{}

func (m *ProductRatePlan) validateInvoiceIssueTypeEnum(path, location string, value string) error {
	if productRatePlanInvoiceIssueTypeEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["Immediate","Delayed","Manual"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanInvoiceIssueTypeEnum = append(productRatePlanInvoiceIssueTypeEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanInvoiceIssueTypeEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateInvoiceIssueType(formats strfmt.Registry) error {

	if err := m.validateInvoiceIssueTypeEnum("invoiceIssueType", "body", m.InvoiceIssueType); err != nil {
		return err
	}

	return nil
}

var productRatePlanIssuePeriodEnum []interface{}

func (m *ProductRatePlan) validateIssuePeriodEnum(path, location string, value string) error {
	if productRatePlanIssuePeriodEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["minutes","days","months","years"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanIssuePeriodEnum = append(productRatePlanIssuePeriodEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanIssuePeriodEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateIssuePeriod(formats strfmt.Registry) error {

	if err := m.validateIssuePeriodEnum("issuePeriod", "body", m.IssuePeriod); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validateLocalisedTax(formats strfmt.Registry) error {

	if err := validate.Required("localisedTax", "body", bool(m.LocalisedTax)); err != nil {
		return err
	}

	return nil
}

var productRatePlanMigrationBehaviourEnum []interface{}

func (m *ProductRatePlan) validateMigrationBehaviourEnum(path, location string, value string) error {
	if productRatePlanMigrationBehaviourEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["NoCharge","CreditAccount"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanMigrationBehaviourEnum = append(productRatePlanMigrationBehaviourEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanMigrationBehaviourEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateMigrationBehaviour(formats strfmt.Registry) error {

	if err := validate.Required("migrationBehaviour", "body", string(m.MigrationBehaviour)); err != nil {
		return err
	}

	if err := m.validateMigrationBehaviourEnum("migrationBehaviour", "body", m.MigrationBehaviour); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validatePricingComponents(formats strfmt.Registry) error {

	return nil
}

var productRatePlanProRataModeEnum []interface{}

func (m *ProductRatePlan) validateProRataModeEnum(path, location string, value string) error {
	if productRatePlanProRataModeEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["None","WithCoupon","WithoutCoupon","Full"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanProRataModeEnum = append(productRatePlanProRataModeEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanProRataModeEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateProRataMode(formats strfmt.Registry) error {

	if err := validate.Required("proRataMode", "body", string(m.ProRataMode)); err != nil {
		return err
	}

	if err := m.validateProRataModeEnum("proRataMode", "body", m.ProRataMode); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validateProductID(formats strfmt.Registry) error {

	if err := validate.Required("productID", "body", string(m.ProductID)); err != nil {
		return err
	}

	return nil
}

var productRatePlanProductTypeEnum []interface{}

func (m *ProductRatePlan) validateProductTypeEnum(path, location string, value string) error {
	if productRatePlanProductTypeEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["nonrecurring","recurring"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanProductTypeEnum = append(productRatePlanProductTypeEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanProductTypeEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateProductType(formats strfmt.Registry) error {

	if err := m.validateProductTypeEnum("productType", "body", m.ProductType); err != nil {
		return err
	}

	return nil
}

var productRatePlanRecursionTypeEnum []interface{}

func (m *ProductRatePlan) validateRecursionTypeEnum(path, location string, value string) error {
	if productRatePlanRecursionTypeEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["nonrecurring","recurring"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanRecursionTypeEnum = append(productRatePlanRecursionTypeEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanRecursionTypeEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateRecursionType(formats strfmt.Registry) error {

	if err := m.validateRecursionTypeEnum("recursionType", "body", m.RecursionType); err != nil {
		return err
	}

	return nil
}

var productRatePlanTaxStatusEnum []interface{}

func (m *ProductRatePlan) validateTaxStatusEnum(path, location string, value string) error {
	if productRatePlanTaxStatusEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["inclusive","exclusive"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanTaxStatusEnum = append(productRatePlanTaxStatusEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanTaxStatusEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateTaxStatus(formats strfmt.Registry) error {

	if err := validate.Required("taxStatus", "body", string(m.TaxStatus)); err != nil {
		return err
	}

	if err := m.validateTaxStatusEnum("taxStatus", "body", m.TaxStatus); err != nil {
		return err
	}

	return nil
}

var productRatePlanTrialPeriodEnum []interface{}

func (m *ProductRatePlan) validateTrialPeriodEnum(path, location string, value string) error {
	if productRatePlanTrialPeriodEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["none","minutes","days","months"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanTrialPeriodEnum = append(productRatePlanTrialPeriodEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanTrialPeriodEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateTrialPeriod(formats strfmt.Registry) error {

	if err := m.validateTrialPeriodEnum("trialPeriod", "body", m.TrialPeriod); err != nil {
		return err
	}

	return nil
}
